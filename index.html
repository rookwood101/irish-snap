<!DOCTYPE html>
<meta charset="UTF-8">
<title>Irish Snap!</title>
<style>
    .card-table {
        width: min(80vw, 80vh);
        aspect-ratio: 1 / 1;
        border-radius: 50%;
        background-color: darkgreen;
        position: relative;
        border: min(4.8vw, 4.8vh) solid saddlebrown;
        font-size: min(2vw, 2vh);
        font-family: sans-serif;
    }

    .card-table-player-name {
        font-size: min(8vw, 8vh);
    }

    .card-table-play-pile {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: min(15vw, 15vh);
    }

    .speech-bubble {
        position: absolute;
        bottom: 0;
        right: 0;
        width: min(5vw, 5vh);
        height: min(2.5vw, 2.5vh);
        border-radius: 50%;
        background: white;
        filter: drop-shadow(1px 1px 0 #000) drop-shadow(-1px 1px 0 #000) drop-shadow(1px -1px 0 #000) drop-shadow(-1px -1px 0 #000);
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .speech-bubble::before {
        content: "";
        position: absolute;
        top: -20%;
        left: -20%;
        border-radius: 0% 100% 0 0;
        width: min(2vw, 2vh);
        height: min(1vw, 1vh);
        box-shadow:  min(0.7vw, 0.7vh) 0 0 white;
    }

    .playing-card {
        width: min(10vw, 10vh);
    }
</style>
<script type="module">
    import { h, Component, render } from 'https://esm.sh/preact@10.11.3'
    import { signal } from "https://esm.sh/@preact/signals@1.1.3"
    import htm from "https://esm.sh/htm@3.1.1"
    import produce from "https://esm.sh/immer@9.0.19"
    import { io } from "https://cdn.socket.io/4.5.4/socket.io.esm.min.js";

    const socket = io()

    // Initialize htm with Preact
    const html = htm.bind(h);

    const invalidStateException = Symbol("Invalid State Exception")
    const cardValues = ["Ace", "2", "3", "4", "5", "6", "7", "8", "9", "10", "Jack", "Queen", "King"]
    const cardSuits = ["Spades", "Hearts", "Diamonds", "Clubs"]
    const allCards = cardValues.flatMap((v) => cardSuits.map((s) => [v, s]));
    class Server {
        constructor(clientUpdateState) {
            // initial state
            const hands = this.#deal(3)
            this.state = {
                status: "valid",
                moves: [],
                played: [],
                said: [],
                players: {
                    "ðŸ˜Ž": {
                        hand: hands[0],
                        updateState: clientUpdateState,
                    },
                    "ðŸ˜´": {
                        hand: hands[1],
                        updateState: (_newState) => {},
                    },
                    "ðŸ¤‘": {
                        hand: hands[2],
                        updateState: (_newState) => {},
                    }
                },
            }
            this.#updateState((draft) => draft)
        }

        #deal(numPlayers) {
            const deck = allCards.slice()
            this.#shuffleArray(deck)
            return this.#splitArray(deck, numPlayers)
        }
        #shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        #splitArray(array, nChunks) {
            let result = [];
            for (let i = nChunks; i > 0; i--) {
                result.push(array.splice(0, Math.ceil(array.length / i)));
            }
            return result;
        }

        /** The card value expected to be said next */
        #expectedToSayNext() {
            const saidLast = this.state.said[this.state.said.length - 1] ?? "King"
            return cardValues[(cardValues.indexOf(saidLast) + 1) % cardValues.length]
        }

        /** The player expected to play next */
        #expectedToPlayNext() {
            const playerOrder = Object.keys(this.state.players)
            const lastSayAndPlay = this.state.moves.findLast((move) => move.action === "sayAndPlay")
            if (lastSayAndPlay === undefined) {
                return playerOrder[0]
            }
            return playerOrder[(playerOrder.indexOf(lastSayAndPlay.player) + 1) % playerOrder.length]
        }

        #shouldSlap() {
            const saidLast = this.state.said[this.state.said.length - 1] ?? NaN
            const playedLastLast = this.state.played[this.state.played.length - 2]?.[0] ?? NaN
            const playedLast = this.state.played[this.state.played.length - 1]?.[0] ?? NaN

            return saidLast === playedLast || playedLastLast === playedLast || playedLast === "Jack"
        }

        #updateState(stateUpdater) {
            const newState = produce(this.state, stateUpdater)
            console.log(newState)
            this.state = newState
            Object.values(this.state.players).forEach(player => {
                player.updateState({
                    lastMove: this.state.moves[this.state.moves.length - 1],
                    playedLast: this.state.played[this.state.played.length - 1],
                    players: Object.fromEntries(Object.entries(this.state.players).map(
                        ([playerName, playerData]) => [playerName, { handSize: playerData.hand.length }]
                    )),
                    status: this.state.status,
                })
            })
        }

        sendReceiveAction(player, action, payload) {
            if (this.state.status !== "valid") {
                return
            }

            switch (action) {
                case "sayAndPlay":
                    const said = payload
                    const expectedToSayNext = this.#expectedToSayNext()
                    const expectedToPlayNext = this.#expectedToPlayNext()

                    this.#updateState(draftState => {
                        const played = draftState.players[player].hand.pop()
                        draftState.moves.push({
                            timestamp: new Date(),
                            action,
                            played,
                            said,
                            player,
                        })
                        draftState.played.push(played)
                        draftState.said.push(said)
                        if (this.#shouldSlap()) {
                            draftState.status = `Somebody should've slapped!`
                            return
                        }
                        if (expectedToPlayNext !== player) {
                            draftState.status = `Player ${expectedToPlayNext} should've gone, not you ${player}!\n`
                            return
                        }
                        if (said !== expectedToSayNext) {
                            draftState.status = `Player ${player} should've said ${expectedToSayNext}!\n`
                            return
                        }
                    })
                    break
                case "slap":
                    this.#updateState(draftState => {
                        draftState.moves.push({
                            timestamp: new Date(),
                            action,
                            player,
                        })
                        if (this.#shouldSlap()) {
                            draftState.status = `Player ${player} slapped first!`
                        } else {
                            draftState.status = `Player ${player} shouldn't have slapped!`
                        }
                    })
                    break
                default:
                    break
            }
        }
    }

    const state = signal({
        lastMove: undefined,
        playedLast: undefined,
        players: {},
        status: "valid",
    })

    function updateState(newState) {
        state.value = newState
        if (state.value.status !== "valid") {
            setTimeout(() => alert(state.value.status), 1)
        }
    }
    const server = new Server(updateState)
    const currentPlayer = "ðŸ˜Ž"
    // preload card images
    allCards.forEach((card) => {
        new Image().src = getPlayingCardSvgPath(card)
    })

    function sayAndPlay(player, said) {
        if (state.value.status !== "valid") {
            alert("Nuh uh!")
            return
        }
        server.sendReceiveAction(player, "sayAndPlay", said);
    }

    function slap(player) {
        if (state.value.status !== "valid") {
            alert("Nuh uh!")
            return
        }
        server.sendReceiveAction(player, "slap", null)
    }

    function getPlayingCardSvgPath(card) {
        let svgIdentifier = "uu" // fallback
        if (card) {
            const value = card[0]
            const suit = card[1]

            svgIdentifier = `${value === "10" ? "10" : value[0]}${suit[0]}`
        }

        return `images/Minicard_${svgIdentifier}.svg`
    }

    function PlayingCard({ card }) {
        return html`<img class="playing-card" src=${getPlayingCardSvgPath(card)} />`
    }

    function SayAndPlayButton({ cardValue, forPlayer }) {
        return html`<button onClick=${() => sayAndPlay(forPlayer, cardValue)}>${cardValue}</button>`
    }

    function CardTable({ state, currentPlayer }) {
        const players = state.players
        const nPlayers = Object.keys(players).length
        return html`
            <div class="card-table">
                ${Object.entries(players).map(([playerName, playerData], i) => html`
                    <div style="
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: rotate(${i*(360.0/nPlayers)}deg) translate(max(-40vw, -40vh));
                    ">
                        <div class="card-table-seat" style="
                            transform: rotate(-${i*(360.0/nPlayers)}deg) translate(-50%, -50%);
                            background: white;
                            border: min(1.6vw, 1.6vh) solid ${playerName === currentPlayer ? "black" : "saddlebrown"};
                            border-radius: 50%;
                            width: min(16vw, 16vh);
                            height: min(16vw, 16vh);
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        ">
                            <span class="card-table-player-name" style="">${playerName}</span>
                            ${state.lastMove?.action === "sayAndPlay" && state.lastMove?.player === playerName && html`
                                <div class="speech-bubble">
                                    ${state.lastMove?.player === playerName ? state.lastMove?.said : undefined}
                                </div>
                            `}
                        </div>
                    </div>
                `)}
                <div class="card-table-play-pile">
                    <${PlayingCard} card=${state.playedLast} />
                </div>
            </div>
        `
    }

    function App(props) {
        const s = state.value;
        // TODO: contesting rule violations should be done by players, not the server
        // TODO: timeout if player takes too long
        // TODO: networking!
        // TODO: rounds & keeping track if someone wins
        // TODO: show hand and central pile size
        return html`
            <div>
                <div style="
                    display: flex;
                    justify-content: center;
                ">
                    <${CardTable} state=${s} currentPlayer=${currentPlayer} />
                </div>
                ${Object.keys(s.players).map(player => html`
                    <div>${player}</div>
                    <div>${cardValues.map((cardValue) => html`<${SayAndPlayButton} cardValue=${cardValue} forPlayer=${player} />`)}</div>
                    <div><button onClick=${() => slap(player)}>Slap!</button></div>
                `)}
            </div>
        `
    }
    
    render(html`<${App} />`, document.body);
</script>